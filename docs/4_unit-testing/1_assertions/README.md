# 4.1 Unit testing - Assertions

When unit testing a smart contract, we want to be able to compare the result of a function invokation with some expected behaviour.
This is done throw assertions. We would want to assert values, events being emitted and transaction reversals.

In order to be able to test those behaviours, we need to add some features to our smart contract.
We will add:
- an assertion in the `increase_balance` function to ensure the provided amount is not negative
- an event being emitted in the `increase_balance` function to notify when the balance increases

Here is the modified contract we will use:

```python
%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.math import assert_nn

@storage_var
func balance() -> (res : felt):
end

# Define the event
@event
func balance_increased(amount : felt):
end

@external
func increase_balance{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    amount : felt
):
    # Revert the transaction if the amount is negative
    with_attr error_message("Amount cannot be negative"):
        assert_nn(amount)
    end

    let (res) = balance.read()
    balance.write(res + amount)

    # Emit the event
    balance_increased.emit(amount)

    return ()
end

# Returns the current balance.
@view
func get_balance{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (
    res : felt
):
    let (res) = balance.read()
    return (res)
end
```

Now, we are ready to test those new features. Let's dive in !

## nile
`nile` uses `pytest` as unit test framework. All unit tests are written in `python`.
It requires to first deploy a contract before being able to interact with it.

### Assert on function return values

Here is the example generated by the `nile init` command:
```python
@pytest.mark.asyncio
async def test_increase_balance():
    """Test increase_balance method."""
    # Create a new Starknet class that simulates the StarkNet
    # system.
    starknet = await Starknet.empty()

    # Deploy the contract.
    contract = await starknet.deploy(
        source=CONTRACT_FILE,
    )

    # Invoke increase_balance() twice.
    await contract.increase_balance(amount=10).invoke()
    await contract.increase_balance(amount=20).invoke()

    # Check the result of get_balance().
    execution_info = await contract.get_balance().call()
    assert execution_info.result == (30,)
```

As `nile` uses pytest as unit test framework, we get all the features of python and pytest for assertions.


### Assert on reverted transaction

Now let's test a function call that is expected to revert
Again, to test this we need some helper functions
```python
async def assert_revert(fun, reverted_with=None):
    try:
        await fun
        assert False
    except StarkException as err:
        _, error = err.args
        if reverted_with is not None:
            assert reverted_with in error["message"]

@pytest.mark.asyncio
async def test_increase_balance():
    # ...

    # Check for transaction revert
    await assert_revert(contract.increase_balance(amount=-1).invoke(), "Amount cannot be negative")
```

### Assert on event emissions

In order to test the event emission, we can check the execution_info variable in the unit test. For that, we need a bit of helpers functions.
Utils functions can be found no [OpenZeppelin repository](https://github.com/OpenZeppelin/cairo-contracts/blob/main/tests/utils.py)

```python
from starkware.starknet.business_logic.execution.objects import Event
from starkware.starknet.public.abi import get_selector_from_name

def assert_event_emitted(tx_exec_info, from_address, name, data):
    assert (
        Event(
            from_address=from_address,
            keys=[get_selector_from_name(name)],
            data=data,
        )
        in tx_exec_info.raw_events
    )

@pytest.mark.asyncio
async def test_increase_balance():
    # ...
    execution_info = await contract.increase_balance(amount=10).invoke()
    assert_event_emitted(execution_info, contract.contract_address, 'balance_increased', [10])
```

:heavy_check_mark: relies on proven `pytest` framework <br/>
:heavy_check_mark: power of python to build test data and perform assertions

:x: need to be familiar with `python` <br/>
:x: need to explicitely deploy the contract to test it<br/>


## protostar
Let's do the same exercise with `protostar`.
`protostar` uses its own unit test framework, which is basically a smart contract with assertions.
Unit tests are written in `cairo`.

Here is the test contract generated by the `protostar init` command.

```python
%lang starknet
from src.main import balance, increase_balance
from starkware.cairo.common.cairo_builtins import HashBuiltin

@view
func test_increase_balance{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}():
    let (result_before) = balance.read()
    assert result_before = 0

    increase_balance(42)

    let (result_after) = balance.read()
    assert result_after = 42
    return ()
end

@view
func test_cannot_increase_balance_with_negative_value{
    syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*
}():
    let (result_before) = balance.read()
    assert result_before = 0

    %{ expect_revert("TRANSACTION_FAILED", "Amount must be positive") %}
    increase_balance(-42)

    return ()
end
```

### Assert on function return values

Assertions are quite limited in cairo, that's why protostar provides a bunch of additionals assert functions:
```python
from protostar.asserts import (
    assert_eq, assert_not_eq, assert_signed_lt, assert_signed_le, assert_signed_gt,
    assert_unsigned_lt, assert_unsigned_le, assert_unsigned_gt, assert_signed_ge,
    assert_unsigned_ge)
```

It is true that assertion failure messages are not very explicit:
```
[FAIL] tests/test_main.cairo test_increase_balance                                                                                                                   
[type] TRANSACTION_FAILED
[code] 39
[details]:
tests/test_main.cairo:20:5: Error at pc=0:245:
An ASSERT_EQ instruction failed: 43 != 42.
    assert result_after = 42  # Added the mocked provided value
    ^**********************^
Cairo traceback (most recent call last):
tests/test_main.cairo:6:6: (pc=0:255)
func test_increase_balance{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}():
     ^*******************^
```

But it can be improved by using the `with_attr error_message()` feature of cairo:

```python
    let (local result_after) = balance.read()
    local expected_result = 42

    with_attr error_message(
            "Invalid balance after update, expected {expected_result}, got {result_after}"):
        assert result_after = expected_result  # Added the mocked provided value
    end
```

Which would result in the following error message:
```
Error message: Invalid balance after update, expected 42, got 43
```

### Assert on reverted transaction

As you can see, it already covers the revert assertions.
All specific behaviour, that are not possible in cairo, are covered by hints. Such hints are called "Cheat codes".
The `expect_revert` is one of them.

### Assert on event emissions

Let's check the event emission now, again using a cheat code. Please note that this cheat code is available since version 0.2.0

```python
@view
func test_increase_balance{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}():
    # ...
    %{ expect_events({"name": "balance_increased", "data": [42]}) %}
    increase_balance(42)
    # ...
    return ()
end
```

:heavy_check_mark: uses same language as smart contract development <br/>
:heavy_check_mark: can still use `python` hints to manipulate data or perform assertions <br/>
:heavy_check_mark: nice output


## Conclusion

| nile                                                   | protostar                                                                                |
| ------------------------------------------------------ | ---------------------------------------------------------------------------------------- |
| :heavy_check_mark: relies on proven `pytest` framework | :heavy_check_mark: uses same language as smart contract development                      |
| :heavy_check_mark: all the power of python             | :heavy_check_mark: can still use `python` hints to manipulate data or perform assertions |
| :x: need to be familiar with `python`                  | :heavy_check_mark: nice output                                                           |
| :x: need to explicitely deploy the contract to test it |                                                                                          |

